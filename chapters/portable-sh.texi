@c -*-texinfo-*-

@ignore LW
This chapter is too informal at certain points--please finish all
sentences, and don't break with code.  It's confusing, and often leads
to the explanations not being quite as clear as they could be.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

This chapter is a whistle stop tour of the accumulated wisdom of the
free software community, with respect to best practices for portable
shell scripting, as encoded in the sources for Autoconf and Libtool, as
interpreted and filtered by me.  It is by no means comprehensive --
entire books have been devoted to the subject -- though it is, I hope,
authoritative.
@ignore LW
Pretty long first sentence.  May want to break up.  Since this isn't
comprehensive, are there areas you don't cover that are covered in resources
you'd recommend to the reader?

2000-07-03  Gary V. Vaughan

        It's long on purpose.  I don't know of any specifically -- all
        of this is hard won by experience alone =(O|

PE
Excellent intro

2000-07-03  Gary V. Vaughan

        Thanks =)O|
@end ignore

@menu
* Why Use the Bourne Shell?::
* Sh Implementation::
* Environment::
* Utilities::
@end menu

@node Why Use the Bourne Shell?
@section Why Use the Bourne Shell?

Unix has been around for more than thirty years and has splintered into
hundreds of small and not so small variants, @xref{Unix Diversity, The
Diversity of Unix Systems}.  Much of the subject matter of this book is
concerned with how best to approach writing programs which will work on
as many of these variants as possible.  One of the few programming tools
that is absolutely guaranteed to be present on every flavour of Unix in
use today is Steve Bourne's original shell, @command{sh} -- the Bourne
Shell.  That is why Libtool is written as a Bourne Shell script, and why
the @command{configure} files generated by Autoconf are Bourne Shell
scripts: they can be executed on all known Unix flavours, and as a bonus
on most @sc{posix} based non-Unix operating systems too.
@ignore LW
You switch from "is written" to "we" within one sentence (the last)--may
want to fix for clarity.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

However, there are complications.  Over the years, @acronym{OS} vendors
have improved Steve Bourne's original shell or have reimplemented it in
an almost, but not quite, compatible way.  There also a great number of
Bourne compatible shells which are often used as a system's default
@samp{/bin/sh}: @command{ash}, @command{bash}, @command{bsh},
@command{ksh}, @command{sh5} and @command{zsh} are some that you may
come across.  For the rest of this chapter, when I say ``shell'', I mean
a Bourne compatible shell.
@ignore LW
Seems strange to follow up the word "problem" with "improve."  Might want
some clarification.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

This leads us to the black art known as @dfn{portable shell
programming}, the art of writing a single script which will run
correctly through all of these varying implementations of
@samp{/bin/sh}.  Of course, Unix systems are constantly evolving and new
variations are being introduced all the time (and very old systems which
have fallen into disuse can perhaps be ignored by the pragmatic).  The
amount of system knowledge required to write a truly portable shell
script is vast, and a great deal of the information that sets a
precedent for a given idiom is necessarily second or third (or tenth)
hand.  Practically, this means that some of the knowledge accumulated in
popular portable shell scripts is very probably folklore -- but that
doesn't really matter too much, the important thing is that if you
adhere to these idioms, you shouldn't have any problems from people who
can't run your program on their system.


@node Sh Implementation
@section Implementation

By their very nature, a sizeable part of the functionality of shell
scripts, is provided by the many utility programs that they routinely
call to perform important subsidiary tasks.  Addressing the portability
of the script involves issues of portability in the host operating
system environment, and portability of the utility programs as well as
the portability of the shell implementation itself.
@ignore LW
First sent. has a lot of elements to it-you may want to break it up a bit for
clarity. Should you say what part of its nature make it that way?

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

This section discusses differences between shell implementations to
which you must cater when writing a portable script.  It is broken into
several subsections, each covering a single aspect of shell programming
that needs to be approached carefully to avoid pitfalls with unexpected
behaviour in some shell implementations.  The following section
discusses how to cope with the host environment in a portable fashion.
The last section in this chapter addresses the portability of common
shell utilities.
@ignore LW
Lots of subsections for this one--you may want to explain what's covered a bit
for flow.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@menu
* Size Limitations::
* Magic Numbers::
* Colon::
* Functions::
* Source::
* Test::
* Variables::
* Pattern Matching::
@end menu

@node Size Limitations
@subsection Size Limitations

Quite a lot of the Unix vendor implementations of the Bourne shell have
a fixed buffer for storing command lines, as small as 512 characters in
the worst cases.  You may have an error akin to this:

@example
$ ls -d /usr/bin/* | wc -l
sh: error: line too long
@end example

Notice that the limit applies to the @emph{expanded} command line, not
just the characters typed in for the line.  A portable way to write this
would be:

@example
$ ( cd /usr/bin && ls | wc -l )
   1556
@end example


@node Magic Numbers
@subsection #!

When the kernel executes a program from the file system, it checks the
first few bytes of the file, and compares them with its internal list of
known @dfn{magic numbers}, which encode how the file can be executed.
This is a similar, but distinct, system to the @file{/etc/magic} magic
number list used by user space programs.

Having determined that the file is a script by examining its magic
number, the kernel finds the path of the interpreter by removing the
@samp{#!} and any intervening space from the first line of the script.
One optional argument is allowed (additional arguments are not ignored,
they constitute a syntax error), and the resulting command line is
executed.  There is a 32 character limit to the significant part of the
@samp{#!} line, so you must ensure that the full path to the interpreter
plus any switches you need to pass to it do not exceed this limit.
Also, the interpreter must be a real binary program, it cannot be a
@samp{#!} file itself.

It used to be thought, that the semantics between different kernels'
idea of the magic number for the start of an interpreted script varied
slightly between implementations.  In actual fact, all look for
@samp{#!} in the first two bytes -- in spite of commonly held beliefs,
there is no evidence that there are others which require @samp{#! /}.
@ignore PE
This paragraph above (and the one after "A portable script") might be moved
to the end of the section. It somewhat interrupts the flow of what the kernel
is doing:
kernel looks at numbers
stuff
stuff
kernel finishing looking at magic numbers

2000-07-03  Gary V. Vaughan

        Okay.

2000-06-12  Akim Demaille
s/that The/that the/.

2000-07-03  Gary V. Vaughan

        Thanks.
@end ignore

A portable script must give an absolute path to the interpreter, which
causes problems when, say, some machines have a better version of Bourne
shell in an unusual directory -- say @file{/usr/sysv/bin/sh}.  See
@ref{Functions, ()} for a way to re-execute the script with a better
interpreter.

For example, imagine a script file called @file{/tmp/foo.pl} with the
following first line:
@ignore LW
Incomplete sentence--please finish the thought.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@example
#! /usr/local/bin/perl
@end example

@noindent
Now, the script can be executed from the @file{tmp} directory, with the
following sequence of commands:
@ignore LW
Please finish the sentence.  Too confusing broken up like this.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@example
$ cd /tmp
$ ./foo.pl
@end example

@noindent
When executing these commands, the kernel will actually execute the
following from the @file{/tmp} directory directory:

@example
/usr/local/bin/perl ./foo.pl
@end example

@ignore
2000-06-12  Akim Demaille
Maybe you wish to talk about the `#!env' idiom: your file starts with
`#! /usr/bin/env foo', and it will call `foo FILE' after having looked
into the PATH.  This 1. let's you honor the PATH to look for the tool,
and 2. unless `foo' has a extraordinarily long name, you no longer take
the risk to hit the 32 chars limit.

2000-07-03  Gary V. Vaughan

        I haven't come across this before.  But it is an extremely good
        suggestion.  Thanks.
@end ignore

@cindex #!env
This can pose problems of its own though.  A script such as the one
described above will not work on a machine where the perl interpreter is
installed as @file{/usr/bin/perl}.  There is a way to circumvent this
problem, by using the @command{env} program to find the interpreter by
looking in the user's @samp{PATH} environment variable.  Change the
first line of the @file{foo.pl} to read as follows:

@example
#! /usr/bin/env perl
@end example

@noindent
This idiom does rely on the @command{env} command being installed as
@file{/usr/bin/env}, and that, in this example, @command{perl} can be
found in the user's @samp{PATH}.  But that is indeed the case on the
great majority of machines.  In contrast, perl is installed in
@file{usr/local/bin} as often as @file{/usr/bin}, so using @command{env}
like this is a net win overall.  You can also use this method to get
around the 32 character limit if the path to the interpreter is too
long.

Unfortunately, you lose the ability to pass an option flag to the
interpreter if you choose to use @command{env}.  For example, you can't
do the following, since it requires two arguments:

@example
#! /usr/bin/env guile -s
@end example


@node Colon
@subsection :
@ignore LW
This section might flow better without the bulleted items--the items are
so long that it can be confusing.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

In the beginning, the magic number for Bourne shell scripts used to be a
colon followed by a newline.  Most Unices still support this, and will
correctly pass a file with a single colon as its first line to
@file{/bin/sh} for interpretation.  Nobody uses this any more and I
suspect some very new Unices may have forgotten about it entirely, so
you should stick to the more usual @samp{#! /bin/sh} syntax for your own
scripts.  You may occasionally come across a very old script that starts
with a @samp{:} though, and it is nice to know why!

In addition, all known Bourne compatible shells have a builtin command,
@samp{:} which always returns success.  It is equivalent to the system
command @command{/bin/true}, but can be used from a script without the
overhead of starting another process.  When setting a shell variable as
a flag, it is good practice to use the commands, @command{:} and
@command{false} as values, and choose the sense of the variable to be
@samp{:} in the common case:  When you come to test the value of the
variable, you will avoid the overhead of additional processes most of
the time.

@example
var=:
if $var; then
  foo
fi
@end example

The @command{:} command described above can take any number of
arguments, which it will fastidiously ignore.  This allows the @samp{:}
character to double up as a comment leader of sorts.  Be aware that the
characters that follow are not discarded, they are still interpreted by
the shell, so metacharacters can have unexpected effects:
@ignore LW
Last sentence very long--you may want to break up for clarity.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@example
$ cat foo
:
: echo foo
m4_changequote(,)m4_dnl
: `echo bar`
: `echo baz >&2'
m4_changequote(`,')m4_dnl
$ ./foo
baz
@end example

You may find very old shell scripts that are commented using @samp{:},
or new scripts that exploit this behavior in some esoteric fashion.  My
advice is, don't:  It will bite you later.


@node Functions
@subsection ()

There are still a great number of shells that, like Steve Bourne's
original implementation, do not have functions! So, strictly speaking,
you can't use shell functions in your scripts.  Luckily, in this day and
age, even though @file{/bin/sh} itself may not support shell functions,
it is not too far from the truth to say that almost every machine will
have @emph{some} shell that does.

Taking this assumption to its logical conclusion, it is a simple matter
of writing your script to find a suitable shell, and then feed itself to
that shell so that the rest of the script can use functions with
impunity:

@example
m4_include(examples/reexec.texi)
@end example
@ignore PE (inserted by LW)
Where IFS="$ etc appear, Phil has said: also mentioning that this is a space-
tab combo would help, like the end of 22.2.b does.

2000-07-03  Gary V. Vaughan

        Okay.

2000-06-12  Akim Demaille
I think it is very bad to promote IFS=space-tab: you must promote
space-tab-nl, in that order.

Why is newline important?  For instance:

	% cat /tmp/foo.sh
	#! /bin/sh

	IFS="   "
	for i in `ls /tmp /home -d`
	do
	  echo =$i=
	done
	% /tmp/foo.sh
	=/home
	/tmp=

OK, here we don't care, but it's good practice.

2000-07-03  Gary V. Vaughan

        Okay.

2000-06-12  Akim Demaille
In fact, your shell code should set IFS unconditionally, IMHO.

2000-07-03  Gary V. Vaughan

        But then the user can't override IFS with their own setting.  I
        carefully set it to the value I need when I use it, and then put
        it back how it was when I'm done (roughly speaking).

2000-06-12  Akim Demaille
Also, you might want to fail with a diagnostic just before the last
`fi'.  It is not supposed to happen, but...

2000-07-03  Gary V. Vaughan

        Okay.  Spotted a few small bugs here myself too.
@end ignore

@noindent
Note that this script finds a shell that supports functions of the
following syntax, since the use of the @code{function} keyword is much
less widely supported:

@example
foo () @{ ... @}
@end example

A notable exception to the assertion that all machines have a shell that
can handle functions is @sc{4.3bsd}, which has only a single shell: a
shell function deprived Bourne shell.  There are two ways you can deal
with this:

@enumerate 1
@item
Ask @sc{4.3bsd} users of your script to install a more featureful shell
such as bash, so that the technique above will work.

@item
Have your script run itself through @command{sed}, chopping itself into
pieces, with each function written to it's own script file, and then
feed what's left into the original shell.  Whenever a function call is
encountered, one of the fragments from the original script will be
executed in a subshell.
@ignore LW
Described with bullet above--should be in bullet above for clarity.

2000-07-03  Gary V. Vaughan

        Nope.  They are definitely two separate points.
@end ignore
@end enumerate

If you decide to split the script with @command{sed}, you will need to
be careful not to rely on shell variables to communicate between
functions, since each ``function'' will be executed in its own subshell.


@node Source
@subsection .

The semantics of @samp{.} are rather peculiar to say the least.  Here is
a simple script -- it just displays its positional parameters:

@example
#! /bin/sh
echo "$0" $@{1+"$@@"@}
@end example

@noindent
Put this in a file, @file{foo}.  Here is another simple script -- it
calls the first script.  Put this in another file, @file{wrapper}:

@example
#! /bin/sh
. ./foo
. ./foo bar baz
@end example

@noindent
Observe what happens when you run this from the command line:
@ignore LW
Make this a complete sentence--say more.

2000-07-03  Gary V. Vaughan

	Okay.
@end ignore

@example
$ ./wrapper
./wrapper
./wrapper bar baz
@end example

@noindent
So @samp{$0} is inherited from the calling script, and the positional
parameters are as passed to the command.  Observe what happens when you
call the wrapper script with arguments:
@ignore LW
This last thought is incomplete--say what you mean.

2000-07-03  Gary V. Vaughan

	Okay.
@end ignore

@example
$ ./wrapper 1 2 3
./wrapper 1 2 3
./wrapper bar baz
@end example

@noindent
So the sourced script has access to the calling scripts positional
parameters, @emph{unless you override them in the @samp{.} command}.

This can cause no end of trouble if you are not expecting it, so you
must either be careful to omit all parameters to any @samp{.} command,
or else don't reference the parameters inside the sourced script.  If
you are reexecuting your script with a shell that understands functions,
the best use for the @samp{.} command is to load libraries of functions
which can subsequently be used in the calling script.

Most importantly, don't forget that, if you call the @command{exit}
command in a script that you load with @samp{.}, it will cause the
calling script to exit too!


@node Test
@subsection [

Although technically equivalent, @command{test} is preferable to
@command{[} in shell code written in conjunction with Autoconf, since
@samp{[} is also used for M4 quoting in Autoconf.  Your code will be
much easier to read (and write) if you abstain from the use of @samp{[}.

Except in the most degenerate shells, @command{test} is a shell builtin
to save the overhead of starting another process, and is no slower than
@samp{[}.  It does mean, however, that there is a huge range of features
which are not implemented often enough that you can use them freely
within a truly portable script.   The less obvious ones to avoid are
@option{-a} and @option{-o} -- the logical ``and'' and ``or''
operations.  A good litmus test for the portability of any shell feature
is to see whether that feature is used in the source of Autoconf, and it
turns out that @option{-a} and @option{-o} @emph{are} used here and
there, but never more than once in a single command.  All the same, to
avoid any confusion, I always avoid them entirely.  I would not use the
following, for example:

@example
test foo -a bar
@end example

@noindent
Instead I would run test twice, like this:

@example
test foo && test bar
@end example

@ignore
2000-06-12  Akim Demaille
IMHO, you are three times wrong :)

-a and -o are fine *alone*, they just have wrong precedence on some
shells.  But Autoconf does use them from place to place.

And `test !' is fine.  What is not fine is `if ! ...'.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@ignore LW
too informal here.

2000-07-03  Gary V. Vaughan

        Okay
@end ignore

The negation operator of @command{test} is quite portable and can be
used in portable shell scripts.  For example:

@example
if test ! foo; then bar; fi
@end example

The negation operator of @command{if} is not at all portable and should
be avoided.  The following would generate a syntax error on some shell
implementations:

@example
if ! test foo; then bar; fi
@end example

An implication of this axiom is that when you need to branch if a
command fails, and that command is not @command{test}, you cannot use
the negation operator.  The easiest way to work around this is to use
the @samp{else} clause of the un-negated @command{if}, like this:

@example
if foo; then :; else bar; fi
@end example

@noindent
Notice the use of the @command{:} builtin as a null operation when
@command{foo} doesn't fail.

The @command{test} command does not cope with missing or additional
arguments, so you must take care to ensure that the shell does not
remove arguments or introduce new ones during variable and quote
expansions.  The best way to do that is to enclose any variables in
double quotes.  You should also add a single character prefix to both
sides in case the value of the expansion is a valid option to
@command{test}:
@ignore PE
this implies that the following example will show you this situation.

2000-07-03  Gary V. Vaughan

        It does!  But, point taken, rather badly.  Padded out somewhat.
@end ignore

@example
$ for foo in "" "!" "bar" "baz quux"; do
>   test x"$foo" = x"bar" && echo 1 || echo 0
> done
0
0
1
0
@end example

@noindent
Here, you can see that using the @samp{x} prefix for the first operand
saves @command{test} from interpreting the @samp{!} argument as a real
option, or from choking on an empty string -- something you must always
be aware of, or else the following behaviour will ensue:

@example
$ foo=!
$ test "$foo" = "bar" && echo 1 || echo 0
test: argument expected
0
$ foo=""
$ test "$foo" = "bar" && echo 1 || echo 0
test: argument expected
0
@end example

@noindent
Also, the double quote marks help @command{test} cope with strings that
contain whitespace.  Without the double quotes, you will see this errors:

@example
$ foo="baz quux"
$ test x$foo = "bar" && echo 1 || echo 0
test: too many arguments
0
@end example

You shouldn't rely on the default behaviour of test (to return ``true''
if its single argument has non-zero length), use the @option{-n} option
to force that behaviour if it is what you want.  Beyond that, the other
thing you need to know about @command{test}, is that if you use operators
other than those below, you are reducing the portability of your code:
@ignore LW
Rather than left to mention, perhaps "left you need to know"--which directs
it more at reader.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@table @asis
@item @option{-n} @var{string}
@var{string} is non-empty.
@item @option{-z} @var{string}
@var{string} is empty.
@item @var{string1} = @var{string2}
Both strings are identical.
@item @var{string1} != @var{string2}
The strings are not the same.
@item @option{-d} @var{file}
@var{file} exists and is a directory.
@item @option{-f} @var{file}
@var{file} exists and is a regular file.
@end table

@ignore
2000-06-12  Akim Demaille
`-e' is not portable (Solaris most notably).  `-d' is portable.

2000-07-03  Gary V. Vaughan

        Wow.  Thanks.
@end ignore

You can also use the following, provided that you don't mix them within
a single invocation of @command{test}:

@table @asis
@item @var{expression} @option{-a} @var{expression}
Both expressions evaluate to ``true''.
@item @var{expression} @option{-o} @var{expression}
Neither expression evaluates to ``false''.
@end table


@node Variables
@subsection $

When using shell variables in your portable scripts, you need to write
them in a somewhat stylised fashion to maximise the number of
shell implementations that will interpret your code as expected:
@ignore LW
The things in this section are not ALL things you do, but instead simply
things that break with the standard form--modify language here or in
items?  This problem makes the formatting of the section somewhat awkward.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore
@itemize @bullet
@item
Convenient though it is, the @sc{posix} @samp{$(command parameters)}
syntax for command substitution is not remotely portable.  Despite it
being more difficult to nest, you must use
m4_changequote(,)m4_dnl
@samp{`command parameters`} instead.
m4_changequote(`,')m4_dnl
@ignore LW
HOw is this an adjustment you make?

2000-07-03  Gary V. Vaughan

        Poor choice of words.  Thanks.
@end ignore

@item
The most portable way to set a default value for a shell variable is:

@example
$ echo $@{no_such_var-"default value"@}
default value
@end example

@noindent
If there is any whitespace in the default value, as there is here, you
must be careful to quote the entire value, since some shells will raise
an error:

@example
$ echo $@{no_such_var-default value@}
sh: bad substitution
@end example

@item
The @command{unset} command is not available in many of the degenerate
Bourne shell implementations.  Generally, it is not too difficult to get
by without it, but following the logic that led to the shell script in
@ref{Functions, ()}, it would be trivial to extend the test case for
confirming a shell's suitability to include a check for @command{unset}.
Although it has not been put to the test, the theory is that all the
interesting machines in use today have @emph{some} shell that supports
@command{unset}.
@ignore PE
Nitpick--reexec.sh is not labeled as such in that section.

2000-07-03  Gary V. Vaughan

        Good call.  Thanks.
@end ignore

@item
Be religious about double quoting variable expansions.  Using
@samp{"$foo"} will avoid trouble with unexpected spaces in filenames,
and compression of all whitespace to a single space in unquoted variable
expansions.

@item
To avoid accidental interpretation of variable expansions as command
options you can use the following technique:

@example
$ foo=-n
$ echo $foo
$ echo x"$foo" | sed -e 's/^x//'
-n
@end example

@item
If it is set, @code{IFS} splits words on whitespace by default.  If you
change it, be sure to put it back when you're done, or the shell may
behave very strangely from that point.  For example, when you need to
examine each element of @samp{$PATH} in turn:
@ignore LW
NOt necessarily something you do.

2000-07-03  Gary V. Vaughan

        Changed the intro paragraph.  Thanks.

LW
Introduce this code please.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@c Warning: the save_IFS line below cannot be split by an editor!
@example
# The whitespace at the end of the following line is a space
# followed by literal tab and newline characters.
save_IFS="$@{IFS=
@}"; IFS=":"
set dummy $PATH
IFS="$save_IFS"
shift
@end example

Alternatively, you can take advantage of the fact that command
substitutions occur in a separate subshell, and do not corrupt the
environment of the calling shell:

@example
@ifhtml
set dummy ``IFS=:; echo $PATH`
@end ifhtml
@ifnothtml
set dummy `IFS=:; echo $PATH`
@end ifnothtml
shift
@end example

@ignore PE
Here in reexec.sh, it may help less experimental scripters if you
explain why IFS might be changed (to break up PATH)

2000-07-03  Gary V. Vaughan

        Okay.

2000-06-12  Akim Demaille
Don't promote setting IFS at the last second, have a line that sets it
once for all to the right value.  IMHO.

2000-07-03  Gary V. Vaughan

        I disagree.  The user may wish to (or need) to set IFS to a
        specific value for some reason.  Within a script, setting it at
        the last minute is exactly the right thing to do.

2000-06-12  Akim Demaille
Also, how about

set dummy `IFS=":"; echo $PATH`
shift

Also, you don't always need the dummy.  Here I wouldn't fear

set `IFS=":"; echo $PATH`

but your solution is definitely better.  Personally, i think too much
care is taken with `set', which is kind of surprising since that
probably one of the less risky builtins: there is only the dash problem.

2000-07-03  Gary V. Vaughan

        All worth a mention.  Thanks.
@end ignore

@noindent
Strictly speaking, the @samp{dummy} argument is required to stop the
@command{set} command from interpreting the first word of the expanded
backquote expression as a command option.
Realistically, no one is going to have @samp{-x}, for example, as the
first element of their @samp{PATH} variable, so the @samp{dummy} could
be omitted -- as I did earlier in the script in @ref{Functions, ()}.

@item
Some shells expand @samp{$@@} to the empty string, even when there are
no actual parameters (@samp{$#} is 0).  If you need to replicate the
parameters that were passed to the executing script, when feeding the
script to a more suitable interpreter for example, you must use the
following:

@example
$@{1+"$@@"@}
@end example

@noindent
Similarly, although all known shells do correctly use @samp{$@@} as the
default argument to a @command{for} command, you must write it like this:

@example
for arg
do
  stuff
done
@end example

@ignore LW
Not easy to read when you break up sentences w/code listings like this.
You don't explain the example very thoroughly here--it's a bit confusing.

2000-07-03  Gary V. Vaughan

	Okay.
@end ignore

@noindent
When you rely on implicit @samp{$@@} like this, it is important to write
the @command{do} keyword on a separate line.  Some degenerate shells
can not parse the following:

@example
for arg; do
  stuff
done
@end example
@end itemize


@node Pattern Matching
@subsection * versus .*

This section compares @dfn{file globbing} with @dfn{regular expression
matching}.   There are many Unix commands which are regularly used from
shell scripts, and which provide some sort of pattern matching
mechanism: @command{expr}, @command{egrep} and @command{sed}, to name a
few.  Unfortunately they each have different quoting rules regarding
whether particular meta-characters must be backslash escaped to revert
to their literal meaning and vice-versa.  There is no real logic
@ignore LW
You can't start a new section assuming they've read everything in your
last---it won't hurt to repeat your point again rather than 'in other words"

2000-07-03  Gary V. Vaughan

        I was refering to the title (* vs. .*), but you are right, it
        was a poor sentence.

LW
NO particular logic to what?

2000-07-03  Gary V. Vaughan

        Oops.  Thanks.
@end ignore
to the particular dialect of regular expressions accepted by these
commands.  To confirm the correctness of each regular expression, you
should always check them from the shell prompt with the relevant tool
before committing to a script, so I won't belabour the specifics.

Shell globbing however is much more regular (no pun intended), and
provides a reasonable and sometimes more cpu efficient solution to many
shell matching problems.  The key is to make good use of the
@command{case} command, which is easier to use (because it uses globbing
rules) and doesn't require additional processes to be spawned.
Unfortunately, @sc{gnu} Bash doesn't handle backslashes correctly in
glob character classes -- the backslash must be the first character in
the class, or else it will never match.  For example, if you want to
detect absolute directory paths on Unix and Windows using
@command{case}, you should write the code like this:

@example
case $dir in
  [\\/]* | ?:[\\/]* ) echo absolute ;;
  * )                 echo relative ;;
esac
@end example

Even though @command{expr} uses regular expressions rather than shell
globbing, it is often@footnote{Notable exceptions are @sc{gnu} Bash,
and both Ksh and the Bourne shell on Solaris.} a shell builtin, so using
it to extract sections of strings can be faster than spawning a sed
process to do the same.  As with @command{echo} and @command{set}, for
example, you must be careful that variable or command expansions for the
first argument to @command{expr} are not accidentally interpreted as
reserved keywords.   As with @command{echo}, you can work around this
problem by prefixing any expansions with a literal @samp{x}, as follows:

@example
$ foo=substr
$ expr $foo : '.*\(str\)'
expr: syntax error
$ expr x$foo : '.*\(str\)'
str
@end example

@ignore PE
for "it is usually" not under solaris 8 at least, for sh, ksh, nor bash 2.x

2000-07-03  Gary V. Vaughan

	Okay.  Thanks.
@end ignore


@node Environment
@section Environment
@ignore LW
You just went through quite a few subsections--better to transition more here.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

In addition to the problems with portability in shell implementations
discussed in the previous section, the behaviour of the shell can also
be drastically affected by the contents of certain environment
variables, and the operating environment provided by the host machine.

It is important to be aware of the behavior of some of the operating
systems within which your shell script might run.  Although not directly
related to the implementation of the shell interpreter, the
characteristics of some of target architectures do influence what is
considered to be portable.  To ensure your script will work on as many
shell implementations as possible, you must observe the following
points.
@ignore LW
Last sentence confusing--I'd switch around To enable your script to run
on...follow these points..."  something like that.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@acronym{SCO} Unix doesn't like @code{LANG=C} and friends, but without
@code{LC_MESSAGES=C}, Solaris will translate variable values in
@code{set}!  Similarly, without @code{LC_CTYPE=C}, compiled C code can
behave unexpectedly.  The trick is to set the values to @samp{C}, except
for if they are not already set at all:

@example
for var in LANG LC_ALL LC_MESSAGES LC_CTYPES LANGUAGES
do
  if eval test x"\$@{$var+set@}" = xset; then
    eval $var=C; eval export $var
  fi
done
@end example

@ignore
2000-06-12  Akim Demaille
Not very beautiful this list :(  You should give it once, and list the
bad guys.  You're missing LANGUAGE BTW.  How about

for var in LANG LC_ALL LC_MESSAGES LC_CTYPES LANGUAGES
do
  eval test x"\${$var+set}" = xset &&
   { eval $var=C; eval export $var; }
done

2000-07-03  Gary V. Vaughan

        Cool.  Thankyou.
@end ignore

@sc{hp-ux} @command{ksh} and all @sc{posix} shells print the target
directory to standard output if @samp{CDPATH} is set.

@example
if test x"$@{CDPATH+set@}" = xset; then CDPATH=:; export CDPATH; fi
@end example

The target architecture file system may impose limits on your scripts.
IF you want your scripts to run on the architectures which impose these
limits, then your script must adhere to these limits:
@ignore LW
What does "observe to be fully portable" mean?

2000-07-03  Gary V. Vaughan

        Poor wording.  Thanks.
@end ignore

@itemize @bullet
@item
The @sc{iso9660} filesystem, as used on most CD-ROMs, limits nesting of
directories to a maximum depth of twelve levels.

@ignore
2000-06-12  Akim Demaille
I don't understand what the second sentence is supposed to add.

2000-07-03  Gary V. Vaughan

        More words ;-)
@end ignore

@item
Many old Unix filesystems place a 14 character limit on the length of
any filename.  If you care about portability to @acronym{DOS},
@emph{that} has an 8 character limit with an optional extension of 3 or
fewer characters (known as 8.3 notation).
@end itemize

A useful idiom when you need to determine whether a particular pathname
is relative or absolute, which works for @acronym{DOS} targets to follows:
@ignore LW
Seems like a separate thought/note.

2000-07-03  Gary V. Vaughan

        It is.
@end ignore

@example
case "$file" in
  [\\/]* | ?:[\\/]*) echo absolute ;;
  *)                 echo default ;;
esac
@end example


@node Utilities
@section Utilities

@ignore LW
I'd transition more here.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

The utility programs commonly executed by shell scripts can have a huge
impact on the portability of shell scripts, and it is important to know
which utilities are universally available, and any differences certain
implementations of these utilities may exhibit.  According to the
@sc{gnu} standards document, you can rely on having access to these
utilities from your scripts:

@example
cat cmp cp diff echo egrep expr false grep install-info
ln ls mkdir mv pwd rm rmdir sed sleep sort tar test touch true
@end example
@ignore PE
Where does this come from? Which pkg? It's not part of regular Unix flavors;
nor is texinfo

2000-07-03  Gary V. Vaughan

        Huh?  I state where the list is from, and I don't mention pkg or
        texinfo...  you've lost me.

LW
Introduce code more--a bit confusing.

2000-07-03  Gary V. Vaughan

        It isn't code.  I explain that it is a list of utilities that
        you can assume will always be available.
@end ignore

Here are some things that you must be aware of when using some of the
tools listed above:
@ignore LW
Does this really apply to all the items below? I don't think it does.

2000-07-03  Gary V. Vaughan

        I guess assumption was the wrong word.  Redone.
@end ignore

@table @asis
@item @command{cat}
Host architectures supply @command{cat} implementations with
conflicting interpretations of, or entirely missing, the various command
line options.  You should avoid using any command line options to this
command.

@item @command{cp} and @command{mv}
Unconditionally duplicated or otherwise open file descriptors can not be
deleted on many operating systems, and worse on Windows the destination
files cannot even be moved.  Constructs like this must be avoided, for
example.
@ignore LW
How do we know an assumption was made here?  You're implying an
assumption, yes, but it may be too subtle.

2000-07-03  Gary V. Vaughan

        Changed the lead in.
@end ignore

@example
exec > foo
mv foo bar
@end example

@item @command{echo}
The @command{echo} command has at least two flavors:  the one takes a
@option{-n} option to suppress the automatic newline at the end of the
echoed string; the other uses an embedded @samp{\c} notation as the last
character in the echoed string for the same purpose.

If you need to emit a string without a trailing newline character, you
can use the following script fragment to discover which flavor of
@command{echo} you are using:

@example
case `echo "testing\c"`,`echo -n testing` in
  *c*,-n*) echo_n=   echo_c='@footnote{@r{This is a literal newline.}}
' ;;
  *c*,*)   echo_n=-n echo_c= ;;
  *)       echo_n=   echo_c='\c' ;;
esac
@end example

@ignore
2000-06-12  Akim Demaille
I know this is coming from Autoconf, but this does not imply it is
perfect :)  Frankly, what the heck so much bizarre care, and not just

if echo -n testing | grep '.n' >/dev/null;

or

if echo -n testing | grep ^-n' >/dev/null;

or

if echo -n testing | grep [-]n' >/dev/null;

or

case `echo -n testing` in
  -n)

in fact I vote for

case `echo "testing\c"`,`echo -n testing` in
  *c,*) ;;
  *,-n*);;
  *);;
esac

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@noindent
Any @command{echo} command after the shell fragment above, which
shouldn't move the cursor to a new line, can now be written like so:
@ignore LW
Vague--clarify a bit.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

@example
echo $echo_n "prompt:$echo_c"
@end example

In addition, you should try to avoid backslashes in @command{echo}
arguments unless they are expanded by the shell.  Some implementations
interpret them and effectively perform another backslash expansion pass,
where equally many implementations do not.  This can become a really
hairy problem if you need to have an @command{echo} command which
doesn't perform backslash expansion, and in fact the first 150 lines of
the @command{ltconfig} script distributed with Libtool are devoted to
finding such a command.

@item @command{ln}
Not all systems support soft links.  You should use the Autoconf macro
@samp{AC_PROG_LN_S} to discover what the target architecture supports,
and assign the result of that test to a variable.  Whenever you
subsequently need to create a link you can use the command stored in the
variable to do so.

@example
LN_S=@@LN_S@@
...
$LN_S $top_srcdir/foo $dist_dir/foo
@end example

@noindent
Also, you cannot rely on support for the @option{-f} option from all
implementations of @command{ln}.  Use @command{rm} before calling
@command{ln} instead.

@item @command{mkdir}
Unfortunately, @samp{mkdir -p} is not as portable as we might like.  You
must either create each directory in the path in turn, or use the
@command{mkinstalldirs} script supplied by Automake.

@item @command{sed}
When you resort to using @command{sed} (rather, use @command{case} or
@command{expr} if you can), there is no need to introduce command line
scripts using the @option{-e} option.  Even when you want to supply more
than one script, you can use @samp{;} as a command separator.  The
following two lines are equivalent, though the latter is cleaner:

@ignore
2000-06-12  Akim Demaille
`most portable'?  But anyway, I don't agree :) Frankly most of the time
the `-e' is totally useless, it is exceptional IMHO, to see a sed script
starting with a dash, not to say impossible in fact.  It's main point is
having several `-e' methinks.

2000-07-03  Gary V. Vaughan

        Sold.
@end ignore

@example
$ sed -e 's/foo/bar/g' -e '12q' < infile > outfile
$ sed 's/foo/bar/g;12q' < infile > outfile
@end example

Some portability zealots still go to great lengths to avoid @dfn{here
documents} of more than twelve lines.  The twelve line limit is actually
a limitation in some implementations of @command{sed}, which has
gradually seeped into the portable shell folklore as a general limit in
all here documents.  Autoconf, however, includes many here documents
with far more than twelve lines, and has not generated any complaints
from users.  This is testament to the fact that at worst the limit is
only encountered in very obscure cases -- and most likely that it is not
a real limit after all.

@ignore LW
You say "too"--what is this in addition to?

2000-07-03  Gary V. Vaughan

        Autoconf.

2000-06-12  Akim Demaille
I don't agree about the 12 line limit.  In fact, it does not, just see
how long some testing programs in the AC_FUNC series can be.  The 12
line limit was actually a limitations over *sed* which was translated
into a limitation in terms of here docs.

Today, it is very unclear what this limitation is, and honestly, I even
doubt there is one.  Thomas E. Dickey seems to know, so maybe that's the
very guy to ask about it.  But really, Autoconf (CVS and 2.13) does *no*
effort wrt here docs.  All these efforts are for the tools that will use
these here docs.

2000-07-03  Gary V. Vaughan

        I'll buy that.  Thanks.
@end ignore

Also, be aware that branch labels of more than eight characters are not
portable to some imPlementations of @command{sed}.
@end table

@quotation
@dfn{Here documents} are a way of redirecting literal strings into the
standard input of a command.  You have certainly seen them before if you
have looked at other peoples shell scripts, though you may not have
realised what they were called:
@ignore LW
I don't see an ending tag for this quotation.
What do you mean by "here"?
Is this expanding on the limit?  Otherwise, I dont' understand.

2000-07-03  Gary V. Vaughan

        After the example.
        ``here-document'' is a peculiar shell terminology.
        What is `This'? What ``limit''?  You've lost me...
@end ignore

@example
cat >> /tmp/file$$ << _EOF_
This is the text of a "here document"
_EOF_
@end example

@ignore
2000-06-12  Akim Demaille
The `\"' is extremely misleading, I suppose you mean

cat >> /tmp/file$$ << _EOF_
This is the text of a "here document"
_EOF_

2000-07-03  Gary V. Vaughan

        Okay.  Thanks.
@end ignore
@end quotation

Something else to be aware of is that the temporary files created by
your scripts can become a security problem if they are left in
@file{/tmp} or if the names are predictable.  A simple way around this
is to create a directory in @file{/tmp} that is unique to the process
and owned by the process user.  Some machines have a utility program for
just this purpose -- @command{mktemp -d} -- or else you can always fall
back to @code{umask 077 && mkdir /tmp/$$}.  Having created this
directory, all of the temporary files for this process should be written
to that directory, and its contents removed as soon as possible.

@ignore
2000-06-12  Akim Demaille
s/it's contents/its contents/

2000-07-03  Gary V. Vaughan

        Doh!

LW
Transition into next chapter more.

2000-07-03  Gary V. Vaughan

        Okay.
@end ignore

Armed with the knowledge of how to write shell code in a portable
fashion as discussed in this chapter, in combination with the M4 details
from the last chapter, the specifics of combining the two to write your
own Autoconf macros are covered in the next chapter.

@c Local variables:
@c fill-column: 72
@c End:
